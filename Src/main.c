/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

#include <stdio.h>

void button_init();

uint32_t g_buttom_pressed;
uint32_t g_buttom_press_count = 0;

uint32_t volatile *p_EXTI_PR = (uint32_t *)0x40013C14;
uint32_t volatile *p_AHB1_ENR = (uint32_t *)0x40020030;
uint32_t volatile *p_APB2_ENR = (uint32_t *)(0x40023800 + 0x44);

uint32_t volatile *p_GPIOA_MODER = (uint32_t *)(0x40020000 + 0x00);
uint32_t volatile *p_GPIOA_IDR = (uint32_t *)(0x40020000 + 0x10);

uint32_t volatile *p_EXTI0_IMR = (uint32_t *)(0x40013C00 + 0x00);  //Mask register
uint32_t volatile *p_EXIT0_RTSR = (uint32_t *)(0x40013C00 + 0x08); //Rising trigger selection register

uint32_t volatile *p_NVIC_ISER0 = (uint32_t *)0xE000E100;

void EXTI0_IRQHandler();

int main(void)
{
	// By default We don't have to write external instruction for reset of GPIO MOde by default it is in 00.
	button_init();

	// Normal Execution it follows while loop and interrupt occur button_init() called.
	/* Loop forever */
	while (1)
	{
		//		disable the interrupt
		//		because the program is in interrupt mode to go in normal mode
		*p_EXTI0_IMR &= ~(1 << 0);
		if (g_buttom_pressed)
		{
			//			Provide some delay for switch debouncing(Mechanical)
			for (uint32_t volatile i = 0; i < 1000000000000000 / 2; i++)
				; //For delay only
			g_buttom_press_count++;
			printf("Button is Pressed : %lu", g_buttom_press_count);
			g_buttom_pressed = 0;
		}
		//		Enable interrupt
		*p_EXTI0_IMR |= (1 << 0);
	}
}

void button_init()
{
	//   1. GPIOA Clock Enable
	*p_AHB1_ENR |= (1 << 0);

	//	 2.	SYSCFG clock Enable
	*p_APB2_ENR |= (1 << 14);

	//	 3. Edge detection Configuration
	*p_EXIT0_RTSR |= (1 << 0);

	//	 4. EXIT interrupt Enable
	*p_EXTI0_IMR |= (1 << 0); //Mask Register of EXTI0
 
    // 	 5.	NVIC irq enable. 
	*p_NVIC_ISER0 |= (1 << 6);

	//	6. Check Button status
	//	g_buttom_pressed=(uint32_t)p_GPIOA_IDR;// Please look Bug
}

	//2. SYSCFG clock Enable
	// *pAPB2ENR |= (1 << 14);


	//check the button status
		//g_button_pressed = (uint32_t)*pGPIOA_IDR;
// Overriding the implementation

void EXTI0_IRQHandler()
{
	printf("Interrupt Occured\n");
	//	Make this flag set to 1;
	g_buttom_pressed = 1;

	// Clear the Pending register.
	*p_EXTI_PR |= (1 << 0); //disable Pending register because of or gate see diagram EXTI0 and  EXTI0_IMR.
}
